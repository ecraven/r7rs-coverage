<table><thead><tr><th>Scheme</th><th>Ok</th><th>Error</th></tr></thead><tbody>
<tr><td>gambitc-unknown</td><td>68.64686468646865%</td><td>416</td><td>190</td></tr>
<tr><td>cyclone-0.3</td><td>96.6996699669967%</td><td>293</td><td>10</td></tr>
<tr><td>picrin-unknown</td><td>78.49944008958566%</td><td>701</td><td>192</td></tr>
<tr><td>chicken-4.11.0</td><td>91.41914191419141%</td><td>554</td><td>52</td></tr>
<tr><td>racket-v6.10</td><td>79.6%</td><td>199</td><td>51</td></tr>
<tr><td>guile-2.1.4</td><td>81.84818481848185%</td><td>248</td><td>55</td></tr>
<tr><td>gambitc-v4.8.8</td><td>74.82185273159145%</td><td>315</td><td>106</td></tr>
<tr><td>chibi-0.7.3</td><td>100.%</td><td>884</td><td>0</td></tr>
<tr><td>larceny-v0.98</td><td>80.52805280528052%</td><td>488</td><td>118</td></tr>
<tr><td>gauche-0.9.5</td><td>81.77570093457943%</td><td>700</td><td>156</td></tr>
<tr><td>larceny-v1.3</td><td>23.076923076923077%</td><td>3</td><td>10</td></tr>
<tr><td>racket-v6.6</td><td>80.52805280528052%</td><td>488</td><td>118</td></tr>
<tr><td>guile-2.0.13</td><td>81.84818481848185%</td><td>496</td><td>110</td></tr>
<tr><td>mit-9.2.1</td><td>83.31885317115551%</td><td>959</td><td>192</td></tr>
<tr><td>guile-2.2.2</td><td>85.01628664495114%</td><td>261</td><td>46</td></tr>
<tr><td>chicken-4.12.0</td><td>88.98305084745763%</td><td>315</td><td>39</td></tr>
<tr><td>mosh-0.2.7</td><td>75.23316062176166%</td><td>726</td><td>239</td></tr>
</tbody></table><table><thead><tr><th>Group</th><th>Ok</th><th>Error</th></tr></thead><tbody>
<tr><td>r7rs/macros</td><td>94.54545454545455</td><td>416</td><td>24</td></tr>
<tr><td>r7rs/strings</td><td>80.55555555555556</td><td>928</td><td>224</td></tr>
<tr><td>r7rs/parameters</td><td>81.81818181818181</td><td>54</td><td>12</td></tr>
<tr><td>r7rs/bytevectors</td><td>59.79020979020979</td><td>171</td><td>115</td></tr>
<tr><td>r7rs/pair-list</td><td>95.92711682743837</td><td>895</td><td>38</td></tr>
<tr><td>r7rs/characters</td><td>66.88382193268187</td><td>616</td><td>305</td></tr>
<tr><td>r7rs/equivalence</td><td>96.36363636363636</td><td>954</td><td>36</td></tr>
<tr><td>srfi-1/srfi-1</td><td>68.359375</td><td>175</td><td>81</td></tr>
<tr><td>r7rs/numeric</td><td>84.20015760441292</td><td>2137</td><td>401</td></tr>
<tr><td>r7rs/delay</td><td>43.63636363636363</td><td>48</td><td>62</td></tr>
<tr><td>r7rs/symbol</td><td>91.40625</td><td>117</td><td>11</td></tr>
<tr><td>r7rs/special-forms</td><td>100.</td><td>132</td><td>0</td></tr>
<tr><td>r7rs/define</td><td>100.</td><td>183</td><td>0</td></tr>
<tr><td>r7rs/vectors</td><td>75.92592592592592</td><td>656</td><td>208</td></tr>
<tr><td>r7rs/control</td><td>74.54545454545455</td><td>451</td><td>154</td></tr>
<tr><td>r7rs/boolean</td><td>89.68253968253968</td><td>113</td><td>13</td></tr>
</tbody></table><section><h2>gambitc-unknown</h2>
<h3>r7rs/macros</h3>
<h4>|ERROR|</h4>
<ul>
<li>let*-values</li>
<li>let*-values</li>
<li>let-values</li>
<li>let-values</li>
<li>unless</li>
<li>unless</li>
<li>when</li>
<li>when</li>
<li>case</li>
<li>case</li>
</ul>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>string-fill!</li>
<li>string-fill!</li>
<li>string-fill!</li>
<li>string-fill!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy</li>
<li>string-copy</li>
<li>string-copy</li>
<li>string-copy</li>
<li>string->list</li>
<li>string->list</li>
<li>string->list</li>
<li>string->list</li>
<li>string-foldcase</li>
<li>string-foldcase</li>
<li>string-downcase</li>
<li>string-downcase</li>
<li>string-upcase</li>
<li>string-upcase</li>
</ul>
<h3>r7rs/parameters</h3>
<h3>r7rs/bytevectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>utf8->string</li>
<li>utf8->string</li>
<li>bytevector-append</li>
<li>bytevector-append</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-u8-set!</li>
<li>bytevector-u8-set!</li>
<li>bytevector-u8-ref</li>
<li>bytevector-u8-ref</li>
<li>bytevector-length</li>
<li>bytevector-length</li>
<li>make-bytevector</li>
<li>make-bytevector</li>
<li>bytevector?</li>
<li>bytevector?</li>
</ul>
<h3>r7rs/pair-list</h3>
<h4>|ERROR|</h4>
<ul>
<li>list-copy</li>
<li>list-copy</li>
<li>assoc</li>
<li>assoc</li>
<li>member</li>
<li>member</li>
<li>list-set!</li>
<li>list-set!</li>
<li>make-list</li>
<li>make-list</li>
</ul>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>char-foldcase</li>
<li>char-foldcase</li>
<li>digit-value</li>
<li>digit-value</li>
<li>literals</li>
<li>literals</li>
</ul>
<h3>r7rs/equivalence</h3>
<h4>|ERROR|</h4>
<ul>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
</ul>
<h3>srfi-1/srfi-1</h3>
<h4>|ERROR|</h4>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>exact</li>
<li>exact</li>
<li>inexact</li>
<li>inexact</li>
<li>exact-integer-sqrt</li>
<li>exact-integer-sqrt</li>
<li>log</li>
<li>log</li>
<li>rationalize</li>
<li>rationalize</li>
<li>truncate/</li>
<li>truncate/</li>
<li>floor/</li>
<li>floor/</li>
<li>truncate-remainder</li>
<li>truncate-remainder</li>
<li>truncate-quotient</li>
<li>truncate-quotient</li>
<li>floor-remainder</li>
<li>floor-remainder</li>
<li>floor-quotient</li>
<li>floor-quotient</li>
<li>exact-integer?</li>
<li>exact-integer?</li>
</ul>
<h3>r7rs/delay</h3>
<h4>|ERROR|</h4>
<ul>
<li>delay-force</li>
<li>delay-force</li>
<li>make-promise</li>
<li>make-promise</li>
<li>promise?</li>
<li>promise?</li>
</ul>
<h3>r7rs/symbol</h3>
<h4>|ERROR|</h4>
<ul>
<li>symbol=?</li>
<li>symbol=?</li>
</ul>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-append</li>
<li>vector-append</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>list->vector</li>
<li>list->vector</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector-ref</li>
<li>vector-ref</li>
<li>vector-length</li>
<li>vector-length</li>
<li>vector</li>
<li>vector</li>
<li>vector?</li>
<li>vector?</li>
</ul>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>vector-for-each</li>
<li>vector-for-each</li>
<li>string-for-each</li>
<li>string-for-each</li>
<li>for-each</li>
<li>for-each</li>
<li>vector-map</li>
<li>vector-map</li>
<li>vector-map</li>
<li>vector-map</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
<li>map</li>
<li>map</li>
</ul>
<h3>r7rs/boolean</h3>
<h4>|ERROR|</h4>
<ul>
<li>boolean=?</li>
<li>boolean=?</li>
</ul>
</section>
<section><h2>cyclone-0.3</h2>
<h3>r7rs/macros</h3>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>literal</li>
</ul>
<h3>r7rs/parameters</h3>
<h3>r7rs/bytevectors</h3>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h3>r7rs/equivalence</h3>
<h3>srfi-1/srfi-1</h3>
<h4>|ERROR|</h4>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>exact-integer-sqrt</li>
<li>rationalize</li>
<li>nan?</li>
<li>infinite?</li>
</ul>
<h3>r7rs/delay</h3>
<h3>r7rs/symbol</h3>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h3>r7rs/boolean</h3>
</section>
<section><h2>picrin-unknown</h2>
<h3>r7rs/macros</h3>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (string=? (string-foldcase "foo") (string-foldcase "FOO")))</li>
<li>(assert (string=? "foo" (string-downcase "FOO")))</li>
<li>(assert (string=? "FOO" (string-upcase "foo")))</li>
<li>(assert (string-ci>=? "b" "B" "a" "A"))</li>
<li>(assert (string-ci&lt;=? "a" "A" "b" "B"))</li>
<li>(assert (string-ci>? "c" "B" "a"))</li>
<li>(assert (string-ci&lt;? "a" "B" "c"))</li>
<li>(assert (string-ci=? "foo" "FOO" (string #\f #\o #\o)))</li>
<li>string-foldcase</li>
<li>string-foldcase</li>
<li>string-downcase</li>
<li>string-downcase</li>
<li>string-upcase</li>
<li>string-upcase</li>
<li>string-ci>=?</li>
<li>string-ci>=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci>?</li>
<li>string-ci>?</li>
<li>string-ci&lt;?</li>
<li>string-ci&lt;?</li>
<li>string-ci=?</li>
<li>string-ci=?</li>
</ul>
<h3>r7rs/parameters</h3>
<h3>r7rs/bytevectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>utf8->string</li>
<li>utf8->string</li>
</ul>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (char=? #\a (char-downcase #\A)))</li>
<li>(assert (char=? #\A (char-upcase #\a)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-lower-case? #\a))</li>
<li>(assert (char-upper-case? #\A))</li>
<li>(assert (char-whitespace? #\space))</li>
<li>(assert (char-numeric? #\1))</li>
<li>(assert (char-alphabetic? #\a))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci>? #\c #\B #\a))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (char=? #\a (char-downcase #\A)))</li>
<li>(assert (char=? #\A (char-upcase #\a)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-lower-case? #\a))</li>
<li>(assert (char-upper-case? #\A))</li>
<li>(assert (char-whitespace? #\space))</li>
<li>(assert (char-numeric? #\1))</li>
<li>(assert (char-alphabetic? #\a))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci>? #\c #\B #\a))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
<li>char-foldcase</li>
<li>char-foldcase</li>
<li>char-downcase</li>
<li>char-downcase</li>
<li>char-upcase</li>
<li>char-upcase</li>
<li>digit-value</li>
<li>digit-value</li>
<li>char-lower-case?</li>
<li>char-lower-case?</li>
<li>char-upper-case?</li>
<li>char-upper-case?</li>
<li>char-whitespace?</li>
<li>char-whitespace?</li>
<li>char-numeric?</li>
<li>char-numeric?</li>
<li>char-alphabetic?</li>
<li>char-alphabetic?</li>
<li>char-ci>=?</li>
<li>char-ci>=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci>?</li>
<li>char-ci>?</li>
<li>char-ci&lt;?</li>
<li>char-ci&lt;?</li>
<li>char-ci=?</li>
<li>char-ci=?</li>
</ul>
<h3>r7rs/equivalence</h3>
<h3>srfi-1/srfi-1</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (equal? '(#t #t #t) (filter-map odd? '(1 2 3 4 5))))</li>
<li>(assert (equal? '(1 3 5) (filter odd? '(1 2 3 4 5))))</li>
<li>(assert (= 1 (cons* 1)))</li>
<li>(assert (equal? '(1 2 3 . 4) (cons* 1 2 3 4)))</li>
<li>(assert (equal? '(2 . 1) (xcons 1 2)))</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (&lt; (abs (- (angle (make-polar 3 1)) 1)) 0.000001))</li>
<li>(assert (= 3 (magnitude (make-polar 3 1))))</li>
<li>(assert (= 2 (imag-part (make-rectangular 1 2))))</li>
<li>(assert (= 1 (real-part (make-rectangular 1 2))))</li>
<li>(assert (= 1+2i (make-rectangular 1 2)))</li>
<li>(assert (and (> (sqrt 17) 4.123) (&lt; (sqrt 17) 4.124)))</li>
<li>(assert (and (> (atan 2 1) 1.107) (&lt; (atan 2 1) 1.108)))</li>
<li>(assert (and (> (atan 0.5) 0.463) (&lt; (atan 0.5) 0.464)))</li>
<li>(assert (and (> (acos 0.5) 1.047) (&lt; (acos 0.5) 1.048)))</li>
<li>(assert (and (> (asin 0.5) 0.523) (&lt; (asin 0.5) 0.524)))</li>
<li>(assert (and (> (tan 1) 1.557) (&lt; (tan 1) 1.558)))</li>
<li>(assert (and (> (cos 5) 0.283) (&lt; (cos 3) 0.284)))</li>
<li>(assert (and (> (sin 3) 0.141) (&lt; (sin 3) 0.142)))</li>
<li>(assert (and (> (log 10 4) 1.660) (&lt; (log 10 4) 1.661)))</li>
<li>(assert (and (> (log 15) 2.70) (&lt; (log 15) 2.71)))</li>
<li>(assert (and (> (exp 3) 20.085) (&lt; (exp 3) 20.086)))</li>
<li>(assert (= 1/3 (rationalize (exact .3) 1/10)))</li>
<li>(assert (= 17 (denominator 5/17)))</li>
<li>(assert (= 5 (numerator 5/17)))</li>
<li>(assert (= 1/6 (/ 1 2 3)))</li>
<li>(assert (= 1/5 (/ 5)))</li>
<li>(assert (nan? +nan.0))</li>
<li>(assert (infinite? +inf.0))</li>
<li>(assert (finite? 123))</li>
<li>(assert (rational? 3/4))</li>
<li>angle</li>
<li>angle</li>
<li>magnitude</li>
<li>magnitude</li>
<li>make-polar</li>
<li>make-polar</li>
<li>imag-part</li>
<li>imag-part</li>
<li>real-part</li>
<li>real-part</li>
<li>make-rectangular</li>
<li>make-rectangular</li>
<li>sqrt</li>
<li>sqrt</li>
<li>atan</li>
<li>atan</li>
<li>atan</li>
<li>atan</li>
<li>acos</li>
<li>acos</li>
<li>asin</li>
<li>asin</li>
<li>tan</li>
<li>tan</li>
<li>cos</li>
<li>cos</li>
<li>sin</li>
<li>sin</li>
<li>log</li>
<li>log</li>
<li>log</li>
<li>log</li>
<li>exp</li>
<li>exp</li>
<li>rationalize</li>
<li>rationalize</li>
<li>denominator</li>
<li>denominator</li>
<li>numerator</li>
<li>numerator</li>
<li>/</li>
<li>/</li>
<li>/</li>
<li>/</li>
<li>nan?</li>
<li>nan?</li>
<li>infinite?</li>
<li>infinite?</li>
<li>finite?</li>
<li>finite?</li>
<li>rational?</li>
<li>rational?</li>
</ul>
<h3>r7rs/delay</h3>
<h4>|ERROR|</h4>
<ul>
<li>delay-force</li>
<li>delay-force</li>
<li>make-promise</li>
<li>make-promise</li>
<li>promise?</li>
<li>promise?</li>
<li>force</li>
<li>force</li>
<li>delay</li>
<li>delay</li>
</ul>
<h3>r7rs/symbol</h3>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
<li>(assert (string=? "ABC" (string-map char-upcase "abc")))</li>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
<li>(assert (string=? "ABC" (string-map char-upcase "abc")))</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
</ul>
<h3>r7rs/boolean</h3>
</section>
<section><h2>chicken-4.11.0</h2>
<h3>r7rs/macros</h3>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>string-foldcase</li>
<li>string-foldcase</li>
<li>string-ci>=?</li>
<li>string-ci>=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci>?</li>
<li>string-ci>?</li>
<li>string-ci&lt;?</li>
<li>string-ci&lt;?</li>
<li>string-ci=?</li>
<li>string-ci=?</li>
</ul>
<h3>r7rs/parameters</h3>
<h3>r7rs/bytevectors</h3>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>char-foldcase</li>
<li>char-foldcase</li>
<li>digit-value</li>
<li>digit-value</li>
<li>char-ci>=?</li>
<li>char-ci>=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci>?</li>
<li>char-ci>?</li>
<li>char-ci&lt;?</li>
<li>char-ci&lt;?</li>
<li>char-ci=?</li>
<li>char-ci=?</li>
</ul>
<h3>r7rs/equivalence</h3>
<h3>srfi-1/srfi-1</h3>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>exact-integer-sqrt</li>
<li>exact-integer-sqrt</li>
<li>log</li>
<li>log</li>
<li>rationalize</li>
<li>rationalize</li>
<li>truncate/</li>
<li>truncate/</li>
<li>floor/</li>
<li>floor/</li>
<li>truncate-remainder</li>
<li>truncate-remainder</li>
<li>truncate-quotient</li>
<li>truncate-quotient</li>
<li>floor-remainder</li>
<li>floor-remainder</li>
<li>floor-quotient</li>
<li>floor-quotient</li>
<li>nan?</li>
<li>nan?</li>
<li>infinite?</li>
<li>infinite?</li>
<li>exact-integer?</li>
<li>exact-integer?</li>
</ul>
<h3>r7rs/delay</h3>
<h3>r7rs/symbol</h3>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>for-each</li>
<li>for-each</li>
</ul>
<h3>r7rs/boolean</h3>
</section>
<section><h2>racket-v6.10</h2>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (string=? (string-foldcase "foo") (string-foldcase "FOO")))</li>
<li>(assert (string=? "foo" (string-downcase "FOO")))</li>
<li>(assert (string=? "FOO" (string-upcase "foo")))</li>
<li>(assert (string-ci>=? "b" "B" "a" "A"))</li>
<li>(assert (string-ci&lt;=? "a" "A" "b" "B"))</li>
<li>(assert (string-ci>? "c" "B" "a"))</li>
<li>(assert (string-ci&lt;? "a" "B" "c"))</li>
<li>(assert (string-ci=? "foo" "FOO" (string #\f #\o #\o)))</li>
</ul>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (char=? #\a (char-downcase #\A)))</li>
<li>(assert (char=? #\A (char-upcase #\a)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-lower-case? #\a))</li>
<li>(assert (char-upper-case? #\A))</li>
<li>(assert (char-whitespace? #\space))</li>
<li>(assert (char-numeric? #\1))</li>
<li>(assert (char-alphabetic? #\a))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci>? #\c #\B #\a))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
</ul>
<h3>r7rs/equivalence</h3>
<h3>srfi-1/srfi-1</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (equal? '(#t #t #t) (filter-map odd? '(1 2 3 4 5))))</li>
<li>(assert (equal? '(1 3 5) (filter odd? '(1 2 3 4 5))))</li>
<li>(assert (= 1 (cons* 1)))</li>
<li>(assert (equal? '(1 2 3 . 4) (cons* 1 2 3 4)))</li>
<li>(assert (equal? '(2 . 1) (xcons 1 2)))</li>
</ul>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (&lt; (abs (- (angle (make-polar 3 1)) 1)) 0.000001))</li>
<li>(assert (= 3 (magnitude (make-polar 3 1))))</li>
<li>(assert (= 2 (imag-part (make-rectangular 1 2))))</li>
<li>(assert (= 1 (real-part (make-rectangular 1 2))))</li>
<li>(assert (= 1+2i (make-rectangular 1 2)))</li>
<li>(assert (and (> (sqrt 17) 4.123) (&lt; (sqrt 17) 4.124)))</li>
<li>(assert (and (> (atan 2 1) 1.107) (&lt; (atan 2 1) 1.108)))</li>
<li>(assert (and (> (atan 0.5) 0.463) (&lt; (atan 0.5) 0.464)))</li>
<li>(assert (and (> (acos 0.5) 1.047) (&lt; (acos 0.5) 1.048)))</li>
<li>(assert (and (> (asin 0.5) 0.523) (&lt; (asin 0.5) 0.524)))</li>
<li>(assert (and (> (tan 1) 1.557) (&lt; (tan 1) 1.558)))</li>
<li>(assert (and (> (cos 5) 0.283) (&lt; (cos 3) 0.284)))</li>
<li>(assert (and (> (sin 3) 0.141) (&lt; (sin 3) 0.142)))</li>
<li>(assert (and (> (log 10 4) 1.660) (&lt; (log 10 4) 1.661)))</li>
<li>(assert (and (> (log 15) 2.70) (&lt; (log 15) 2.71)))</li>
<li>(assert (and (> (exp 3) 20.085) (&lt; (exp 3) 20.086)))</li>
<li>(assert (nan? +nan.0))</li>
<li>(assert (infinite? +inf.0))</li>
<li>(assert (finite? 123))</li>
</ul>
<h3>r7rs/symbol</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(let ((v '())) (string-for-each (lambda (c x) (set! v (cons (char->integer c) v))) "abcde" "abcdef") (assert (equal? '(101 100 99 98 97) v)))</li>
<li>(define x 0) (for-each (lambda (a b c) (set! x (+ x (+ a b c)))) '(1 2 3 4) '(1 2) '(1 2 3)) (assert (= x 9))</li>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
<li>(assert (string=? "ABC" (string-map char-upcase "abc")))</li>
</ul>
<h3>r7rs/boolean</h3>
</section>
<section><h2>guile-2.1.4</h2>
<h3>r7rs/macros</h3>
<h4>|ERROR|</h4>
<ul>
<li>let*-values</li>
<li>let-values</li>
</ul>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>string-foldcase</li>
</ul>
<h3>r7rs/parameters</h3>
<h3>r7rs/bytevectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>utf8->string</li>
<li>bytevector-append</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-u8-set!</li>
<li>bytevector-u8-ref</li>
<li>bytevector-length</li>
<li>make-bytevector</li>
<li>bytevector?</li>
</ul>
<h3>r7rs/pair-list</h3>
<h4>|ERROR|</h4>
<ul>
<li>assoc</li>
<li>member</li>
</ul>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>char-foldcase</li>
<li>digit-value</li>
</ul>
<h3>r7rs/equivalence</h3>
<h4>|ERROR|</h4>
<ul>
<li>eqv?</li>
<li>eqv?</li>
</ul>
<h3>srfi-1/srfi-1</h3>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>exact</li>
<li>inexact</li>
<li>square</li>
<li>log</li>
<li>rationalize</li>
<li>infinite?</li>
</ul>
<h3>r7rs/delay</h3>
<h4>|ERROR|</h4>
<ul>
<li>delay-force</li>
<li>make-promise</li>
</ul>
<h3>r7rs/symbol</h3>
<h4>|ERROR|</h4>
<ul>
<li>symbol=?</li>
</ul>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-append</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->list</li>
<li>vector->list</li>
</ul>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>vector-for-each</li>
<li>string-for-each</li>
<li>for-each</li>
<li>vector-map</li>
<li>vector-map</li>
<li>string-map</li>
<li>map</li>
</ul>
<h3>r7rs/boolean</h3>
<h4>|ERROR|</h4>
<ul>
<li>boolean=?</li>
</ul>
</section>
<section><h2>gambitc-v4.8.8</h2>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>(define s (make-string 3 #\x)) (string-fill! s #\a 1 2) (assert (string=? "xax" s))</li>
<li>(define s (make-string 3 #\x)) (string-fill! s #\a 1) (assert (string=? "xaa" s))</li>
<li>(define s (make-string 5 #\x)) (string-copy! s 0 "xfoo" 1 3) (assert (string=? "fo" (substring s 0 2)))</li>
<li>(define s (make-string 5 #\x)) (string-copy! s 0 "xfoo" 1) (assert (string=? "foo" (substring s 0 3)))</li>
<li>(define s (make-string 5)) (string-copy! s 0 "foo") (assert (string=? "foo" (substring s 0 3)))</li>
<li>(assert (string=? "foo" (string-copy "xfoox" 1 4)))</li>
<li>(assert (string=? "foo" (string-copy "xfoo" 1)))</li>
<li>(assert (equal? '(#\f #\o #\o) (string->list "xfoox" 1 4)))</li>
<li>(assert (equal? '(#\f #\o #\o) (string->list "xfoo" 1)))</li>
<li>(assert (string=? (string-foldcase "foo") (string-foldcase "FOO")))</li>
<li>(assert (string=? "foo" (string-downcase "FOO")))</li>
<li>(assert (string=? "FOO" (string-upcase "foo")))</li>
</ul>
<h3>r7rs/pair-list</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (let ((l '(1 2 3))) (and (not (eq? l (list-copy l))) (equal? l (list-copy l)))))</li>
<li>(assert (equal? '(1 a) (assoc 1 '((1 a) (2 b) (3 c)) =)))</li>
<li>(assert (equal? '(2 3) (member '2 '(1 2 3) =)))</li>
<li>(define l (list 1 2 3)) (list-set! l 1 5) (assert (= 5 (list-ref l 1)))</li>
<li>(assert (= 5 (length (make-list 5))))</li>
</ul>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(list #\alarm #\backspace #\delete #\escape #\newline #\null #\return #\space #\tab)</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(list #\alarm #\backspace #\delete #\escape #\newline #\null #\return #\space #\tab)</li>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
<li>(list #\alarm #\backspace #\delete #\escape #\newline #\null #\return #\space #\tab)</li>
</ul>
<h3>r7rs/equivalence</h3>
<h4>|ERROR|</h4>
<ul>
<li>(let ((a (make-bytevector 3)) (b (make-bytevector 3))) (assert (not (eqv? a b))))</li>
<li>(let ((a (make-list 3)) (b (make-list 3))) (assert (not (eqv? a b))))</li>
<li>(let ((x (make-bytevector 4))) (assert (eqv? x x)))</li>
<li>(let ((a (make-bytevector 3)) (b (make-bytevector 3))) (assert (not (eqv? a b))))</li>
<li>(let ((a (make-list 3)) (b (make-list 3))) (assert (not (eqv? a b))))</li>
<li>(let ((x (make-bytevector 4))) (assert (eqv? x x)))</li>
</ul>
<h3>srfi-1/srfi-1</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (equal? '(#t #t #t) (filter-map odd? '(1 2 3 4 5))))</li>
<li>(assert (equal? '(1 3 5) (filter odd? '(1 2 3 4 5))))</li>
<li>(assert (= 1 (cons* 1)))</li>
<li>(assert (equal? '(1 2 3 . 4) (cons* 1 2 3 4)))</li>
<li>(assert (equal? '(2 . 1) (xcons 1 2)))</li>
</ul>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (exact? (exact 3.0)))</li>
<li>(assert (inexact? (inexact 3)))</li>
<li>(assert (call-with-values (lambda () (exact-integer-sqrt 17)) (lambda (a b) (and (= a 4) (= b 1)))))</li>
<li>(assert (and (> (log 10 4) 1.660) (&lt; (log 10 4) 1.661)))</li>
<li>(assert (= 1/3 (rationalize (exact .3) 1/10)))</li>
<li>(assert (call-with-values (lambda () (truncate/ 5 2)) (lambda (a b) (and (= a 2) (= b 1)))))</li>
<li>(assert (call-with-values (lambda () (floor/ 5 2)) (lambda (a b) (and (= a 2) (= b 1)))))</li>
<li>(assert (= 1 (truncate-remainder 10 -3)))</li>
<li>(assert (= -3 (truncate-quotient 10 -3)))</li>
<li>(assert (= -2 (floor-remainder 10 -3)))</li>
<li>(assert (= -4 (floor-quotient 10 -3)))</li>
<li>(assert (exact-integer? 32))</li>
<li>(assert (exact? (exact 3.0)))</li>
<li>(assert (inexact? (inexact 3)))</li>
<li>(assert (call-with-values (lambda () (exact-integer-sqrt 17)) (lambda (a b) (and (= a 4) (= b 1)))))</li>
<li>(assert (and (> (log 10 4) 1.660) (&lt; (log 10 4) 1.661)))</li>
<li>(assert (= 1/3 (rationalize (exact .3) 1/10)))</li>
<li>(assert (call-with-values (lambda () (truncate/ 5 2)) (lambda (a b) (and (= a 2) (= b 1)))))</li>
<li>(assert (call-with-values (lambda () (floor/ 5 2)) (lambda (a b) (and (= a 2) (= b 1)))))</li>
<li>(assert (= 1 (truncate-remainder 10 -3)))</li>
<li>(assert (= -3 (truncate-quotient 10 -3)))</li>
<li>(assert (= -2 (floor-remainder 10 -3)))</li>
<li>(assert (= -4 (floor-quotient 10 -3)))</li>
<li>(assert (exact-integer? 32))</li>
</ul>
<h3>r7rs/symbol</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (symbol=? 'a 'a (string->symbol "a")))</li>
</ul>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>(define v (make-vector 3 0)) (vector-fill! v 1 1 2) (assert (equal? #(0 1 0) v))</li>
<li>(define v (make-vector 3 0)) (vector-fill! v 1 1) (assert (equal? #(0 1 1) v))</li>
<li>(define v (make-vector 3 0)) (vector-fill! v 1) (assert (equal? #(1 1 1) v))</li>
<li>(assert (equal? #(1 2 3 4) (vector-append #(1 2) #(3 4))))</li>
<li>(define v (make-vector 3 #\x)) (vector-copy! v 0 #(5 1 2 3 4) 1 4) (assert (equal? #(1 2 3) v))</li>
<li>(define v (make-vector 3 #\x)) (vector-copy! v 0 #(5 1 2 3) 1) (assert (equal? #(1 2 3) v))</li>
<li>(define v (make-vector 3)) (vector-copy! v 0 #(1 2 3)) (assert (equal? #(1 2 3) v))</li>
<li>(assert (let ((v #(5 1 2 3 5))) (equal? #(1 2 3) (vector-copy v 1 4))))</li>
<li>(assert (let ((v #(5 1 2 3))) (equal? #(1 2 3) (vector-copy v 1))))</li>
<li>(assert (let ((v #(1 2 3))) (and (equal? v (vector-copy v)) (not (eq? v (vector-copy v))))))</li>
<li>(assert (equal? #(#\f #\o #\o) (string->vector "xfoox" 1 4)))</li>
<li>(assert (equal? #(#\f #\o #\o) (string->vector "xfoo" 1)))</li>
<li>(assert (equal? #(#\f #\o #\o) (string->vector "foo")))</li>
<li>(assert (string=? "foo" (vector->string #(#\x #\f #\o #\o #\x) 1 4)))</li>
<li>(assert (string=? "foo" (vector->string #(#\x #\f #\o #\o) 1)))</li>
<li>(assert (string=? "foo" (vector->string #(#\f #\o #\o))))</li>
<li>(assert (equal? #(1 2 3) (list->vector '(1 2 3))))</li>
<li>(assert (equal? '(1 2 3) (vector->list #(5 1 2 3 6) 1 4)))</li>
<li>(assert (equal? '(1 2 3) (vector->list #(5 1 2 3) 1)))</li>
<li>(assert (equal? '(1 2 3) (vector->list #(1 2 3))))</li>
<li>(assert (= 3 (vector-ref #(1 2 3 4 5) 2)))</li>
<li>(assert (= 5 (vector-length #(1 2 3 4 5))))</li>
<li>(assert (equal? #(1 2 3) (vector 1 2 3)))</li>
<li>(assert (vector? #(1 2 3)))</li>
</ul>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(let ((v '())) (string-for-each (lambda (c x) (set! v (cons (char->integer c) v))) "abcde" "abcdef") (assert (equal? '(101 100 99 98 97) v)))</li>
<li>(define x 0) (for-each (lambda (a b c) (set! x (+ x (+ a b c)))) '(1 2 3 4) '(1 2) '(1 2 3)) (assert (= x 9))</li>
<li>(assert (equal? #(5 7 9) (vector-map + #(1 2 3) #(4 5 6 7))))</li>
<li>(assert (equal? #(1 2 3) (vector-map (lambda (x) (+ x 1)) #(0 1 2))))</li>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
<li>(assert (string=? "ABC" (string-map char-upcase "abc")))</li>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(let ((v '())) (string-for-each (lambda (c x) (set! v (cons (char->integer c) v))) "abcde" "abcdef") (assert (equal? '(101 100 99 98 97) v)))</li>
<li>(define x 0) (for-each (lambda (a b c) (set! x (+ x (+ a b c)))) '(1 2 3 4) '(1 2) '(1 2 3)) (assert (= x 9))</li>
<li>(assert (equal? #(5 7 9) (vector-map + #(1 2 3) #(4 5 6 7))))</li>
<li>(assert (equal? #(1 2 3) (vector-map (lambda (x) (+ x 1)) #(0 1 2))))</li>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
<li>(assert (string=? "ABC" (string-map char-upcase "abc")))</li>
</ul>
<h3>r7rs/boolean</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (boolean=? #t #t))</li>
<li>(assert (boolean=? #t #t))</li>
<li>(assert (boolean=? #t #t))</li>
</ul>
</section>
<section><h2>chibi-0.7.3</h2>
<h3>r7rs/macros</h3>
<h3>r7rs/strings</h3>
<h3>r7rs/parameters</h3>
<h3>r7rs/bytevectors</h3>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h3>r7rs/equivalence</h3>
<h3>srfi-1/srfi-1</h3>
<h3>r7rs/numeric</h3>
<h3>r7rs/delay</h3>
<h3>r7rs/symbol</h3>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h3>r7rs/boolean</h3>
</section>
<section><h2>larceny-v0.98</h2>
<h3>r7rs/macros</h3>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>string-foldcase</li>
<li>string-foldcase</li>
<li>string-downcase</li>
<li>string-downcase</li>
<li>string-upcase</li>
<li>string-upcase</li>
<li>string-ci>=?</li>
<li>string-ci>=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci>?</li>
<li>string-ci>?</li>
<li>string-ci&lt;?</li>
<li>string-ci&lt;?</li>
<li>string-ci=?</li>
<li>string-ci=?</li>
</ul>
<h3>r7rs/parameters</h3>
<h4>|ERROR|</h4>
<ul>
<li>parameterize</li>
<li>parameterize</li>
</ul>
<h3>r7rs/bytevectors</h3>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>char-foldcase</li>
<li>char-foldcase</li>
<li>char-downcase</li>
<li>char-downcase</li>
<li>char-upcase</li>
<li>char-upcase</li>
<li>digit-value</li>
<li>digit-value</li>
<li>char-lower-case?</li>
<li>char-lower-case?</li>
<li>char-upper-case?</li>
<li>char-upper-case?</li>
<li>char-whitespace?</li>
<li>char-whitespace?</li>
<li>char-numeric?</li>
<li>char-numeric?</li>
<li>char-alphabetic?</li>
<li>char-alphabetic?</li>
<li>char-ci>=?</li>
<li>char-ci>=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci>?</li>
<li>char-ci>?</li>
<li>char-ci&lt;?</li>
<li>char-ci&lt;?</li>
<li>char-ci=?</li>
<li>char-ci=?</li>
</ul>
<h3>r7rs/equivalence</h3>
<h3>srfi-1/srfi-1</h3>
<h4>|ERROR|</h4>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>angle</li>
<li>angle</li>
<li>magnitude</li>
<li>magnitude</li>
<li>make-polar</li>
<li>make-polar</li>
<li>imag-part</li>
<li>imag-part</li>
<li>real-part</li>
<li>real-part</li>
<li>make-rectangular</li>
<li>make-rectangular</li>
<li>sqrt</li>
<li>sqrt</li>
<li>atan</li>
<li>atan</li>
<li>atan</li>
<li>atan</li>
<li>acos</li>
<li>acos</li>
<li>asin</li>
<li>asin</li>
<li>tan</li>
<li>tan</li>
<li>cos</li>
<li>cos</li>
<li>sin</li>
<li>sin</li>
<li>log</li>
<li>log</li>
<li>log</li>
<li>log</li>
<li>exp</li>
<li>exp</li>
<li>nan?</li>
<li>nan?</li>
<li>infinite?</li>
<li>infinite?</li>
<li>finite?</li>
<li>finite?</li>
</ul>
<h3>r7rs/delay</h3>
<h4>|ERROR|</h4>
<ul>
<li>delay-force</li>
<li>delay-force</li>
<li>make-promise</li>
<li>make-promise</li>
<li>promise?</li>
<li>promise?</li>
<li>force</li>
<li>force</li>
<li>delay</li>
<li>delay</li>
</ul>
<h3>r7rs/symbol</h3>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>vector-for-each</li>
<li>vector-for-each</li>
<li>string-for-each</li>
<li>string-for-each</li>
<li>for-each</li>
<li>for-each</li>
<li>vector-map</li>
<li>vector-map</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
</ul>
<h3>r7rs/boolean</h3>
</section>
<section><h2>gauche-0.9.5</h2>
<h3>r7rs/macros</h3>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (string=? (string-foldcase "foo") (string-foldcase "FOO")))</li>
<li>(assert (string=? "foo" (string-downcase "FOO")))</li>
<li>(assert (string=? "FOO" (string-upcase "foo")))</li>
<li>(assert (string-ci>=? "b" "B" "a" "A"))</li>
<li>(assert (string-ci&lt;=? "a" "A" "b" "B"))</li>
<li>(assert (string-ci>? "c" "B" "a"))</li>
<li>(assert (string-ci&lt;? "a" "B" "c"))</li>
<li>(assert (string-ci=? "foo" "FOO" (string #\f #\o #\o)))</li>
<li>string-foldcase</li>
<li>string-foldcase</li>
<li>string-downcase</li>
<li>string-downcase</li>
<li>string-upcase</li>
<li>string-upcase</li>
<li>string-ci>=?</li>
<li>string-ci>=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci>?</li>
<li>string-ci>?</li>
<li>string-ci&lt;?</li>
<li>string-ci&lt;?</li>
<li>string-ci=?</li>
<li>string-ci=?</li>
</ul>
<h3>r7rs/parameters</h3>
<h3>r7rs/bytevectors</h3>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (char=? #\a (char-downcase #\A)))</li>
<li>(assert (char=? #\A (char-upcase #\a)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-lower-case? #\a))</li>
<li>(assert (char-upper-case? #\A))</li>
<li>(assert (char-whitespace? #\space))</li>
<li>(assert (char-numeric? #\1))</li>
<li>(assert (char-alphabetic? #\a))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci>? #\c #\B #\a))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
<li>char-foldcase</li>
<li>char-foldcase</li>
<li>char-downcase</li>
<li>char-downcase</li>
<li>char-upcase</li>
<li>char-upcase</li>
<li>digit-value</li>
<li>digit-value</li>
<li>char-lower-case?</li>
<li>char-lower-case?</li>
<li>char-upper-case?</li>
<li>char-upper-case?</li>
<li>char-whitespace?</li>
<li>char-whitespace?</li>
<li>char-numeric?</li>
<li>char-numeric?</li>
<li>char-alphabetic?</li>
<li>char-alphabetic?</li>
<li>char-ci>=?</li>
<li>char-ci>=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci>?</li>
<li>char-ci>?</li>
<li>char-ci&lt;?</li>
<li>char-ci&lt;?</li>
<li>char-ci=?</li>
<li>char-ci=?</li>
</ul>
<h3>r7rs/equivalence</h3>
<h3>srfi-1/srfi-1</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (equal? '(#t #t #t) (filter-map odd? '(1 2 3 4 5))))</li>
<li>(assert (equal? '(1 3 5) (filter odd? '(1 2 3 4 5))))</li>
<li>(assert (= 1 (cons* 1)))</li>
<li>(assert (equal? '(1 2 3 . 4) (cons* 1 2 3 4)))</li>
<li>(assert (equal? '(2 . 1) (xcons 1 2)))</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (&lt; (abs (- (angle (make-polar 3 1)) 1)) 0.000001))</li>
<li>(assert (= 3 (magnitude (make-polar 3 1))))</li>
<li>(assert (= 2 (imag-part (make-rectangular 1 2))))</li>
<li>(assert (= 1 (real-part (make-rectangular 1 2))))</li>
<li>(assert (= 1+2i (make-rectangular 1 2)))</li>
<li>(assert (and (> (sqrt 17) 4.123) (&lt; (sqrt 17) 4.124)))</li>
<li>(assert (and (> (atan 2 1) 1.107) (&lt; (atan 2 1) 1.108)))</li>
<li>(assert (and (> (atan 0.5) 0.463) (&lt; (atan 0.5) 0.464)))</li>
<li>(assert (and (> (acos 0.5) 1.047) (&lt; (acos 0.5) 1.048)))</li>
<li>(assert (and (> (asin 0.5) 0.523) (&lt; (asin 0.5) 0.524)))</li>
<li>(assert (and (> (tan 1) 1.557) (&lt; (tan 1) 1.558)))</li>
<li>(assert (and (> (cos 5) 0.283) (&lt; (cos 3) 0.284)))</li>
<li>(assert (and (> (sin 3) 0.141) (&lt; (sin 3) 0.142)))</li>
<li>(assert (and (> (log 10 4) 1.660) (&lt; (log 10 4) 1.661)))</li>
<li>(assert (and (> (log 15) 2.70) (&lt; (log 15) 2.71)))</li>
<li>(assert (and (> (exp 3) 20.085) (&lt; (exp 3) 20.086)))</li>
<li>(assert (nan? +nan.0))</li>
<li>(assert (infinite? +inf.0))</li>
<li>(assert (finite? 123))</li>
<li>angle</li>
<li>angle</li>
<li>magnitude</li>
<li>magnitude</li>
<li>make-polar</li>
<li>make-polar</li>
<li>imag-part</li>
<li>imag-part</li>
<li>real-part</li>
<li>real-part</li>
<li>make-rectangular</li>
<li>make-rectangular</li>
<li>sqrt</li>
<li>sqrt</li>
<li>atan</li>
<li>atan</li>
<li>atan</li>
<li>atan</li>
<li>acos</li>
<li>acos</li>
<li>asin</li>
<li>asin</li>
<li>tan</li>
<li>tan</li>
<li>cos</li>
<li>cos</li>
<li>sin</li>
<li>sin</li>
<li>log</li>
<li>log</li>
<li>log</li>
<li>log</li>
<li>exp</li>
<li>exp</li>
<li>nan?</li>
<li>nan?</li>
<li>infinite?</li>
<li>infinite?</li>
<li>finite?</li>
<li>finite?</li>
</ul>
<h3>r7rs/delay</h3>
<h4>|ERROR|</h4>
<ul>
<li>delay-force</li>
<li>delay-force</li>
<li>make-promise</li>
<li>make-promise</li>
<li>promise?</li>
<li>promise?</li>
<li>force</li>
<li>force</li>
<li>delay</li>
<li>delay</li>
</ul>
<h3>r7rs/symbol</h3>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
<li>(assert (string=? "ABC" (string-map char-upcase "abc")))</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
</ul>
<h3>r7rs/boolean</h3>
</section>
<section><h2>larceny-v1.3</h2>
<h3>r7rs/boolean</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (boolean=? #t #t))</li>
<li>(assert (boolean? #t))</li>
<li>(assert (eq? #t (not #f)))</li>
</ul>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (char>=? #\b #\b #\a #\a))</li>
<li>(assert (char&lt;=? #\a #\a #\b #\b))</li>
<li>(assert (char>? #\c #\b #\a))</li>
<li>(assert (char&lt;? #\a #\b #\c))</li>
<li>(assert (char=? #\a #\a #\a))</li>
<li>(assert (char? #\a))</li>
<li>(list #\alarm #\backspace #\delete #\escape #\newline #\null #\return #\space #\tab)</li>
</ul>
</section>
<section><h2>racket-v6.6</h2>
<h3>r7rs/macros</h3>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>string-foldcase</li>
<li>string-foldcase</li>
<li>string-downcase</li>
<li>string-downcase</li>
<li>string-upcase</li>
<li>string-upcase</li>
<li>string-ci>=?</li>
<li>string-ci>=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci>?</li>
<li>string-ci>?</li>
<li>string-ci&lt;?</li>
<li>string-ci&lt;?</li>
<li>string-ci=?</li>
<li>string-ci=?</li>
</ul>
<h3>r7rs/parameters</h3>
<h4>|ERROR|</h4>
<ul>
<li>parameterize</li>
<li>parameterize</li>
<li>make-parameter</li>
<li>make-parameter</li>
</ul>
<h3>r7rs/bytevectors</h3>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>char-foldcase</li>
<li>char-foldcase</li>
<li>char-downcase</li>
<li>char-downcase</li>
<li>char-upcase</li>
<li>char-upcase</li>
<li>digit-value</li>
<li>digit-value</li>
<li>char-lower-case?</li>
<li>char-lower-case?</li>
<li>char-upper-case?</li>
<li>char-upper-case?</li>
<li>char-whitespace?</li>
<li>char-whitespace?</li>
<li>char-numeric?</li>
<li>char-numeric?</li>
<li>char-alphabetic?</li>
<li>char-alphabetic?</li>
<li>char-ci>=?</li>
<li>char-ci>=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci>?</li>
<li>char-ci>?</li>
<li>char-ci&lt;?</li>
<li>char-ci&lt;?</li>
<li>char-ci=?</li>
<li>char-ci=?</li>
</ul>
<h3>r7rs/equivalence</h3>
<h3>srfi-1/srfi-1</h3>
<h4>|ERROR|</h4>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>angle</li>
<li>angle</li>
<li>magnitude</li>
<li>magnitude</li>
<li>make-polar</li>
<li>make-polar</li>
<li>imag-part</li>
<li>imag-part</li>
<li>real-part</li>
<li>real-part</li>
<li>make-rectangular</li>
<li>make-rectangular</li>
<li>sqrt</li>
<li>sqrt</li>
<li>atan</li>
<li>atan</li>
<li>atan</li>
<li>atan</li>
<li>acos</li>
<li>acos</li>
<li>asin</li>
<li>asin</li>
<li>tan</li>
<li>tan</li>
<li>cos</li>
<li>cos</li>
<li>sin</li>
<li>sin</li>
<li>log</li>
<li>log</li>
<li>log</li>
<li>log</li>
<li>exp</li>
<li>exp</li>
<li>nan?</li>
<li>nan?</li>
<li>infinite?</li>
<li>infinite?</li>
<li>finite?</li>
<li>finite?</li>
</ul>
<h3>r7rs/delay</h3>
<h4>|ERROR|</h4>
<ul>
<li>delay-force</li>
<li>delay-force</li>
<li>make-promise</li>
<li>make-promise</li>
<li>promise?</li>
<li>promise?</li>
<li>force</li>
<li>force</li>
<li>delay</li>
<li>delay</li>
</ul>
<h3>r7rs/symbol</h3>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>vector-for-each</li>
<li>vector-for-each</li>
<li>string-for-each</li>
<li>string-for-each</li>
<li>for-each</li>
<li>for-each</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
</ul>
<h3>r7rs/boolean</h3>
</section>
<section><h2>guile-2.0.13</h2>
<h3>r7rs/macros</h3>
<h4>|ERROR|</h4>
<ul>
<li>let*-values</li>
<li>let*-values</li>
<li>let-values</li>
<li>let-values</li>
</ul>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>string-foldcase</li>
<li>string-foldcase</li>
</ul>
<h3>r7rs/parameters</h3>
<h3>r7rs/bytevectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>utf8->string</li>
<li>utf8->string</li>
<li>bytevector-append</li>
<li>bytevector-append</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-u8-set!</li>
<li>bytevector-u8-set!</li>
<li>bytevector-u8-ref</li>
<li>bytevector-u8-ref</li>
<li>bytevector-length</li>
<li>bytevector-length</li>
<li>make-bytevector</li>
<li>make-bytevector</li>
<li>bytevector?</li>
<li>bytevector?</li>
</ul>
<h3>r7rs/pair-list</h3>
<h4>|ERROR|</h4>
<ul>
<li>assoc</li>
<li>assoc</li>
<li>member</li>
<li>member</li>
</ul>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>char-foldcase</li>
<li>char-foldcase</li>
<li>digit-value</li>
<li>digit-value</li>
</ul>
<h3>r7rs/equivalence</h3>
<h4>|ERROR|</h4>
<ul>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
</ul>
<h3>srfi-1/srfi-1</h3>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>exact</li>
<li>exact</li>
<li>inexact</li>
<li>inexact</li>
<li>square</li>
<li>square</li>
<li>log</li>
<li>log</li>
<li>rationalize</li>
<li>rationalize</li>
<li>infinite?</li>
<li>infinite?</li>
</ul>
<h3>r7rs/delay</h3>
<h4>|ERROR|</h4>
<ul>
<li>delay-force</li>
<li>delay-force</li>
<li>make-promise</li>
<li>make-promise</li>
</ul>
<h3>r7rs/symbol</h3>
<h4>|ERROR|</h4>
<ul>
<li>symbol=?</li>
<li>symbol=?</li>
</ul>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-append</li>
<li>vector-append</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
</ul>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>vector-for-each</li>
<li>vector-for-each</li>
<li>string-for-each</li>
<li>string-for-each</li>
<li>for-each</li>
<li>for-each</li>
<li>vector-map</li>
<li>vector-map</li>
<li>vector-map</li>
<li>vector-map</li>
<li>string-map</li>
<li>string-map</li>
<li>map</li>
<li>map</li>
</ul>
<h3>r7rs/boolean</h3>
<h4>|ERROR|</h4>
<ul>
<li>boolean=?</li>
<li>boolean=?</li>
</ul>
</section>
<section><h2>mit-9.2.1</h2>
<h3>r7rs/macros</h3>
<h4>|ERROR|</h4>
<ul>
<li>let*-values</li>
<li>let*-values</li>
<li>let-values</li>
<li>let-values</li>
<li>case</li>
<li>case</li>
</ul>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (string=? (string-foldcase "foo") (string-foldcase "FOO")))</li>
<li>(assert (string-ci>=? "b" "B" "a" "A"))</li>
<li>(assert (string>=? "b" "b" "a" "a"))</li>
<li>(assert (string-ci&lt;=? "a" "A" "b" "B"))</li>
<li>(assert (string&lt;=? "a" "a" "b" "b"))</li>
<li>(assert (string-ci>? "c" "B" "a"))</li>
<li>(assert (string>? "c" "b" "a"))</li>
<li>(assert (string-ci&lt;? "a" "B" "c"))</li>
<li>(assert (string&lt;? "a" "b" "c"))</li>
<li>(assert (string-ci=? "foo" "FOO" (string #\f #\o #\o)))</li>
<li>(assert (string=? "foo" "foo" (string #\f #\o #\o)))</li>
<li>(assert (string=? (string-foldcase "foo") (string-foldcase "FOO")))</li>
<li>(assert (string-ci>=? "b" "B" "a" "A"))</li>
<li>(assert (string>=? "b" "b" "a" "a"))</li>
<li>(assert (string-ci&lt;=? "a" "A" "b" "B"))</li>
<li>(assert (string&lt;=? "a" "a" "b" "b"))</li>
<li>(assert (string-ci>? "c" "B" "a"))</li>
<li>(assert (string>? "c" "b" "a"))</li>
<li>(assert (string-ci&lt;? "a" "B" "c"))</li>
<li>(assert (string&lt;? "a" "b" "c"))</li>
<li>(assert (string-ci=? "foo" "FOO" (string #\f #\o #\o)))</li>
<li>(assert (string=? "foo" "foo" (string #\f #\o #\o)))</li>
<li>string-foldcase</li>
<li>string-foldcase</li>
<li>string-ci>=?</li>
<li>string-ci>=?</li>
<li>string>=?</li>
<li>string>=?</li>
<li>string-ci&lt;=?</li>
<li>string-ci&lt;=?</li>
<li>string&lt;=?</li>
<li>string&lt;=?</li>
<li>string-ci>?</li>
<li>string-ci>?</li>
<li>string>?</li>
<li>string>?</li>
<li>string-ci&lt;?</li>
<li>string-ci&lt;?</li>
<li>string&lt;?</li>
<li>string&lt;?</li>
<li>string-ci=?</li>
<li>string-ci=?</li>
<li>string=?</li>
<li>string=?</li>
</ul>
<h3>r7rs/parameters</h3>
<h3>r7rs/bytevectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>utf8->string</li>
<li>utf8->string</li>
<li>bytevector-append</li>
<li>bytevector-append</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-u8-set!</li>
<li>bytevector-u8-set!</li>
<li>bytevector-u8-ref</li>
<li>bytevector-u8-ref</li>
<li>bytevector-length</li>
<li>bytevector-length</li>
<li>make-bytevector</li>
<li>make-bytevector</li>
<li>bytevector?</li>
<li>bytevector?</li>
</ul>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci>? #\c #\B #\a))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
<li>(assert (char>=? #\b #\b #\a #\a))</li>
<li>(assert (char&lt;=? #\a #\a #\b #\b))</li>
<li>(assert (char>? #\c #\b #\a))</li>
<li>(assert (char&lt;? #\a #\b #\c))</li>
<li>(assert (char=? #\a #\a #\a))</li>
<li>(list #\alarm #\backspace #\delete #\escape #\newline #\null #\return #\space #\tab)</li>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci>? #\c #\B #\a))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
<li>(assert (char>=? #\b #\b #\a #\a))</li>
<li>(assert (char&lt;=? #\a #\a #\b #\b))</li>
<li>(assert (char>? #\c #\b #\a))</li>
<li>(assert (char&lt;? #\a #\b #\c))</li>
<li>(assert (char=? #\a #\a #\a))</li>
<li>(list #\alarm #\backspace #\delete #\escape #\newline #\null #\return #\space #\tab)</li>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci>? #\c #\B #\a))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
<li>(assert (char>=? #\b #\b #\a #\a))</li>
<li>(assert (char&lt;=? #\a #\a #\b #\b))</li>
<li>(assert (char>? #\c #\b #\a))</li>
<li>(assert (char&lt;? #\a #\b #\c))</li>
<li>(assert (char=? #\a #\a #\a))</li>
<li>(list #\alarm #\backspace #\delete #\escape #\newline #\null #\return #\space #\tab)</li>
<li>char-foldcase</li>
<li>char-foldcase</li>
<li>digit-value</li>
<li>digit-value</li>
<li>char-ci>=?</li>
<li>char-ci>=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci&lt;=?</li>
<li>char-ci>?</li>
<li>char-ci>?</li>
<li>char-ci&lt;?</li>
<li>char-ci&lt;?</li>
<li>char-ci=?</li>
<li>char-ci=?</li>
<li>char>=?</li>
<li>char>=?</li>
<li>char&lt;=?</li>
<li>char&lt;=?</li>
<li>char>?</li>
<li>char>?</li>
<li>char&lt;?</li>
<li>char&lt;?</li>
<li>char=?</li>
<li>char=?</li>
<li>literals</li>
<li>literals</li>
</ul>
<h3>r7rs/equivalence</h3>
<h4>|ERROR|</h4>
<ul>
<li>(let ((a (make-bytevector 3)) (b (make-bytevector 3))) (assert (not (eqv? a b))))</li>
<li>(let ((x (make-bytevector 4))) (assert (eqv? x x)))</li>
<li>(let ((a (make-bytevector 3)) (b (make-bytevector 3))) (assert (not (eqv? a b))))</li>
<li>(let ((x (make-bytevector 4))) (assert (eqv? x x)))</li>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
</ul>
<h3>srfi-1/srfi-1</h3>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (call-with-values (lambda () (exact-integer-sqrt 17)) (lambda (a b) (and (= a 4) (= b 1)))))</li>
<li>(assert (and (> (log 10 4) 1.660) (&lt; (log 10 4) 1.661)))</li>
<li>(assert (nan? +nan.0))</li>
<li>(assert (infinite? +inf.0))</li>
<li>(assert (finite? 123))</li>
<li>(assert (call-with-values (lambda () (exact-integer-sqrt 17)) (lambda (a b) (and (= a 4) (= b 1)))))</li>
<li>(assert (and (> (log 10 4) 1.660) (&lt; (log 10 4) 1.661)))</li>
<li>(assert (nan? +nan.0))</li>
<li>(assert (infinite? +inf.0))</li>
<li>(assert (finite? 123))</li>
<li>exact-integer-sqrt</li>
<li>exact-integer-sqrt</li>
<li>log</li>
<li>log</li>
<li>nan?</li>
<li>nan?</li>
<li>infinite?</li>
<li>infinite?</li>
<li>finite?</li>
<li>finite?</li>
</ul>
<h3>r7rs/delay</h3>
<h4>|ERROR|</h4>
<ul>
<li>delay-force</li>
<li>delay-force</li>
<li>make-promise</li>
<li>make-promise</li>
</ul>
<h3>r7rs/symbol</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (symbol=? 'a 'a (string->symbol "a")))</li>
<li>(assert (symbol=? 'a 'a (string->symbol "a")))</li>
<li>symbol=?</li>
<li>symbol=?</li>
</ul>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>(call/cc (lambda (k) k))</li>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(assert (equal? #(5 7 9) (vector-map + #(1 2 3) #(4 5 6 7))))</li>
<li>(call/cc (lambda (k) k))</li>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(assert (equal? #(5 7 9) (vector-map + #(1 2 3) #(4 5 6 7))))</li>
<li>(call/cc (lambda (k) k))</li>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(assert (equal? #(5 7 9) (vector-map + #(1 2 3) #(4 5 6 7))))</li>
<li>call/cc</li>
<li>call/cc</li>
<li>vector-for-each</li>
<li>vector-for-each</li>
<li>vector-map</li>
<li>vector-map</li>
</ul>
<h3>r7rs/boolean</h3>
</section>
<section><h2>guile-2.2.2</h2>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (string=? (string-foldcase "foo") (string-foldcase "FOO")))</li>
</ul>
<h3>r7rs/pair-list</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (equal? '(1 a) (assoc 1 '((1 a) (2 b) (3 c)) =)))</li>
<li>(assert (equal? '(2 3) (member '2 '(1 2 3) =)))</li>
</ul>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
</ul>
<h3>r7rs/equivalence</h3>
<h4>|ERROR|</h4>
<ul>
<li>(let ((a (make-bytevector 3)) (b (make-bytevector 3))) (assert (not (eqv? a b))))</li>
<li>(let ((x (make-bytevector 4))) (assert (eqv? x x)))</li>
</ul>
<h3>srfi-1/srfi-1</h3>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (exact? (exact 3.0)))</li>
<li>(assert (inexact? (inexact 3)))</li>
<li>(assert (= 25 (square 5)))</li>
<li>(assert (and (> (log 10 4) 1.660) (&lt; (log 10 4) 1.661)))</li>
<li>(assert (= 1/3 (rationalize (exact .3) 1/10)))</li>
<li>(assert (infinite? +inf.0))</li>
</ul>
<h3>r7rs/symbol</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (symbol=? 'a 'a (string->symbol "a")))</li>
</ul>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>(define v (make-vector 3 0)) (vector-fill! v 1 1 2) (assert (equal? #(0 1 0) v))</li>
<li>(define v (make-vector 3 0)) (vector-fill! v 1 1) (assert (equal? #(0 1 1) v))</li>
<li>(assert (equal? #(1 2 3 4) (vector-append #(1 2) #(3 4))))</li>
<li>(define v (make-vector 3 #\x)) (vector-copy! v 0 #(5 1 2 3 4) 1 4) (assert (equal? #(1 2 3) v))</li>
<li>(define v (make-vector 3 #\x)) (vector-copy! v 0 #(5 1 2 3) 1) (assert (equal? #(1 2 3) v))</li>
<li>(define v (make-vector 3)) (vector-copy! v 0 #(1 2 3)) (assert (equal? #(1 2 3) v))</li>
<li>(assert (let ((v #(5 1 2 3 5))) (equal? #(1 2 3) (vector-copy v 1 4))))</li>
<li>(assert (let ((v #(5 1 2 3))) (equal? #(1 2 3) (vector-copy v 1))))</li>
<li>(assert (equal? #(#\f #\o #\o) (string->vector "xfoox" 1 4)))</li>
<li>(assert (equal? #(#\f #\o #\o) (string->vector "xfoo" 1)))</li>
<li>(assert (equal? #(#\f #\o #\o) (string->vector "foo")))</li>
<li>(assert (string=? "foo" (vector->string #(#\x #\f #\o #\o #\x) 1 4)))</li>
<li>(assert (string=? "foo" (vector->string #(#\x #\f #\o #\o) 1)))</li>
<li>(assert (string=? "foo" (vector->string #(#\f #\o #\o))))</li>
<li>(assert (equal? '(1 2 3) (vector->list #(5 1 2 3 6) 1 4)))</li>
<li>(assert (equal? '(1 2 3) (vector->list #(5 1 2 3) 1)))</li>
</ul>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(let ((v '())) (string-for-each (lambda (c x) (set! v (cons (char->integer c) v))) "abcde" "abcdef") (assert (equal? '(101 100 99 98 97) v)))</li>
<li>(define x 0) (for-each (lambda (a b c) (set! x (+ x (+ a b c)))) '(1 2 3 4) '(1 2) '(1 2 3)) (assert (= x 9))</li>
<li>(assert (equal? #(5 7 9) (vector-map + #(1 2 3) #(4 5 6 7))))</li>
<li>(assert (equal? #(1 2 3) (vector-map (lambda (x) (+ x 1)) #(0 1 2))))</li>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(let ((v '())) (string-for-each (lambda (c x) (set! v (cons (char->integer c) v))) "abcde" "abcdef") (assert (equal? '(101 100 99 98 97) v)))</li>
<li>(define x 0) (for-each (lambda (a b c) (set! x (+ x (+ a b c)))) '(1 2 3 4) '(1 2) '(1 2 3)) (assert (= x 9))</li>
<li>(assert (equal? #(5 7 9) (vector-map + #(1 2 3) #(4 5 6 7))))</li>
<li>(assert (equal? #(1 2 3) (vector-map (lambda (x) (+ x 1)) #(0 1 2))))</li>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
</ul>
<h3>r7rs/boolean</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (boolean=? #t #t))</li>
<li>(assert (boolean=? #t #t))</li>
</ul>
</section>
<section><h2>chicken-4.12.0</h2>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (string=? (string-foldcase "foo") (string-foldcase "FOO")))</li>
<li>(assert (string-ci>=? "b" "B" "a" "A"))</li>
<li>(assert (string-ci&lt;=? "a" "A" "b" "B"))</li>
<li>(assert (string-ci>? "c" "B" "a"))</li>
<li>(assert (string-ci&lt;? "a" "B" "c"))</li>
<li>(assert (string-ci=? "foo" "FOO" (string #\f #\o #\o)))</li>
</ul>
<h3>r7rs/pair-list</h3>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci>? #\c #\B #\a))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
<li>(assert (char=? (char-foldcase #\a) (char-foldcase #\A)))</li>
<li>(assert (char=? #\A (char-upcase #\a)))</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(assert (char-ci>=? #\b #\B #\a #\A))</li>
<li>(assert (char-ci&lt;=? #\a #\A #\b #\B))</li>
<li>(assert (char-ci>? #\c #\B #\a))</li>
<li>(assert (char-ci&lt;? #\a #\B #\c))</li>
<li>(assert (char-ci=? #\a #\A #\a))</li>
</ul>
<h3>r7rs/equivalence</h3>
<h3>srfi-1/srfi-1</h3>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (call-with-values (lambda () (exact-integer-sqrt 17)) (lambda (a b) (and (= a 4) (= b 1)))))</li>
<li>(assert (and (> (log 10 4) 1.660) (&lt; (log 10 4) 1.661)))</li>
<li>(assert (= 1/3 (rationalize (exact .3) 1/10)))</li>
<li>(assert (call-with-values (lambda () (truncate/ 5 2)) (lambda (a b) (and (= a 2) (= b 1)))))</li>
<li>(assert (call-with-values (lambda () (floor/ 5 2)) (lambda (a b) (and (= a 2) (= b 1)))))</li>
<li>(assert (= 1 (truncate-remainder 10 -3)))</li>
<li>(assert (= -3 (truncate-quotient 10 -3)))</li>
<li>(assert (= -2 (floor-remainder 10 -3)))</li>
<li>(assert (= -4 (floor-quotient 10 -3)))</li>
<li>(assert (nan? +nan.0))</li>
<li>(assert (infinite? +inf.0))</li>
<li>(assert (exact-integer? 32))</li>
<li>(assert (nan? +nan.0))</li>
<li>(assert (infinite? +inf.0))</li>
<li>(assert (exact-integer? 32))</li>
</ul>
<h3>r7rs/symbol</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>(define x 0) (for-each (lambda (a b c) (set! x (+ x (+ a b c)))) '(1 2 3 4) '(1 2) '(1 2 3)) (assert (= x 9))</li>
<li>(define x 0) (for-each (lambda (a b c) (set! x (+ x (+ a b c)))) '(1 2 3 4) '(1 2) '(1 2 3)) (assert (= x 9))</li>
<li>(assert (procedure? procedure?))</li>
</ul>
<h3>r7rs/boolean</h3>
</section>
<section><h2>mosh-0.2.7</h2>
<h3>r7rs/macros</h3>
<h4>|ERROR|</h4>
<ul>
<li>case</li>
<li>case</li>
</ul>
<h3>r7rs/strings</h3>
<h4>|ERROR|</h4>
<ul>
<li>(define s (make-string 3 #\x)) (string-fill! s #\a 1 2) (assert (string=? "xax" s))</li>
<li>(define s (make-string 3 #\x)) (string-fill! s #\a 1) (assert (string=? "xaa" s))</li>
<li>(define s (make-string 3 #\x)) (string-fill! s #\a) (assert (string=? "aaa" s))</li>
<li>(define s (make-string 5 #\x)) (string-copy! s 0 "xfoo" 1 3) (assert (string=? "fo" (substring s 0 2)))</li>
<li>(define s (make-string 5 #\x)) (string-copy! s 0 "xfoo" 1) (assert (string=? "foo" (substring s 0 3)))</li>
<li>(define s (make-string 5)) (string-copy! s 0 "foo") (assert (string=? "foo" (substring s 0 3)))</li>
<li>(assert (string=? "foo" (string-copy "xfoox" 1 4)))</li>
<li>(assert (string=? "foo" (string-copy "xfoo" 1)))</li>
<li>(assert (equal? '(#\f #\o #\o) (string->list "xfoox" 1 4)))</li>
<li>(assert (equal? '(#\f #\o #\o) (string->list "xfoo" 1)))</li>
<li>"\a\b\t\n\r\"\\\|\</li>
<li>string-fill!</li>
<li>string-fill!</li>
<li>string-fill!</li>
<li>string-fill!</li>
<li>string-fill!</li>
<li>string-fill!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy!</li>
<li>string-copy</li>
<li>string-copy</li>
<li>string-copy</li>
<li>string-copy</li>
<li>string->list</li>
<li>string->list</li>
<li>string->list</li>
<li>string->list</li>
<li>literal</li>
<li>literal</li>
</ul>
<h3>r7rs/parameters</h3>
<h4>|ERROR|</h4>
<ul>
<li>parameterize</li>
<li>parameterize</li>
<li>make-parameter</li>
<li>make-parameter</li>
<li>make-parameter</li>
<li>make-parameter</li>
</ul>
<h3>r7rs/bytevectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>utf8->string</li>
<li>utf8->string</li>
<li>bytevector-append</li>
<li>bytevector-append</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy!</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-copy</li>
<li>bytevector-u8-ref</li>
<li>bytevector-u8-ref</li>
<li>bytevector-length</li>
<li>bytevector-length</li>
<li>bytevector?</li>
<li>bytevector?</li>
</ul>
<h3>r7rs/pair-list</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (let ((l '(1 2 3))) (and (not (eq? l (list-copy l))) (equal? l (list-copy l)))))</li>
<li>(assert (equal? '(1 a) (assoc 1 '((1 a) (2 b) (3 c)) =)))</li>
<li>(assert (equal? '(2 3) (member '2 '(1 2 3) =)))</li>
<li>(define l (list 1 2 3)) (list-set! l 1 5) (assert (= 5 (list-ref l 1)))</li>
<li>(assert (= 5 (length (make-list 5))))</li>
<li>list-copy</li>
<li>list-copy</li>
<li>assoc</li>
<li>assoc</li>
<li>member</li>
<li>member</li>
<li>list-set!</li>
<li>list-set!</li>
<li>make-list</li>
<li>make-list</li>
</ul>
<h3>r7rs/characters</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(list #\alarm #\backspace #\delete #\escape #\newline #\null #\return #\space #\tab)</li>
<li>(assert (= 3 (digit-value #\3)))</li>
<li>(list #\alarm #\backspace #\delete #\escape #\newline #\null #\return #\space #\tab)</li>
<li>digit-value</li>
<li>digit-value</li>
<li>literals</li>
<li>literals</li>
</ul>
<h3>r7rs/equivalence</h3>
<h4>|ERROR|</h4>
<ul>
<li>(let ((a (make-list 3)) (b (make-list 3))) (assert (not (eqv? a b))))</li>
<li>(assert (not (eqv? 3 3.0)))</li>
<li>(let ((a (make-list 3)) (b (make-list 3))) (assert (not (eqv? a b))))</li>
<li>(assert (not (eqv? 3 3.0)))</li>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
<li>eqv?</li>
</ul>
<h3>srfi-1/srfi-1</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (equal? '(#t #t #t) (filter-map odd? '(1 2 3 4 5))))</li>
<li>(assert (equal? '(2 . 1) (xcons 1 2)))</li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3>r7rs/numeric</h3>
<h4>|ERROR|</h4>
<ul>
<li>(assert (= 25 (square 5)))</li>
<li>(assert (and (> (atan 2 1) 1.107) (&lt; (atan 2 1) 1.108)))</li>
<li>(assert (call-with-values (lambda () (truncate/ 5 2)) (lambda (a b) (and (= a 2) (= b 1)))))</li>
<li>(assert (call-with-values (lambda () (floor/ 5 2)) (lambda (a b) (and (= a 2) (= b 1)))))</li>
<li>(assert (= 1 (truncate-remainder 10 -3)))</li>
<li>(assert (= -3 (truncate-quotient 10 -3)))</li>
<li>(assert (= -2 (floor-remainder 10 -3)))</li>
<li>(assert (= -4 (floor-quotient 10 -3)))</li>
<li>(assert (exact-integer? 32))</li>
<li>(assert (= -3 (truncate-quotient 10 -3)))</li>
<li>(assert (= -2 (floor-remainder 10 -3)))</li>
<li>(assert (= -4 (floor-quotient 10 -3)))</li>
<li>(assert (exact-integer? 32))</li>
<li>square</li>
<li>square</li>
<li>atan</li>
<li>atan</li>
<li>truncate/</li>
<li>truncate/</li>
<li>floor/</li>
<li>floor/</li>
<li>truncate-remainder</li>
<li>truncate-remainder</li>
<li>truncate-quotient</li>
<li>truncate-quotient</li>
<li>floor-remainder</li>
<li>floor-remainder</li>
<li>floor-quotient</li>
<li>floor-quotient</li>
<li>exact-integer?</li>
<li>exact-integer?</li>
</ul>
<h3>r7rs/delay</h3>
<h4>|ERROR|</h4>
<ul>
<li>delay-force</li>
<li>delay-force</li>
<li>make-promise</li>
<li>make-promise</li>
<li>promise?</li>
<li>promise?</li>
</ul>
<h3>r7rs/symbol</h3>
<h3>r7rs/special-forms</h3>
<h3>r7rs/define</h3>
<h3>r7rs/vectors</h3>
<h4>|ERROR|</h4>
<ul>
<li>(define v (make-vector 3 0)) (vector-fill! v 1 1 2) (assert (equal? #(0 1 0) v))</li>
<li>(define v (make-vector 3 0)) (vector-fill! v 1 1) (assert (equal? #(0 1 1) v))</li>
<li>(define v (make-vector 3 0)) (vector-fill! v 1) (assert (equal? #(1 1 1) v))</li>
<li>(assert (equal? #(1 2 3 4) (vector-append #(1 2) #(3 4))))</li>
<li>(define v (make-vector 3 #\x)) (vector-copy! v 0 #(5 1 2 3 4) 1 4) (assert (equal? #(1 2 3) v))</li>
<li>(define v (make-vector 3 #\x)) (vector-copy! v 0 #(5 1 2 3) 1) (assert (equal? #(1 2 3) v))</li>
<li>(define v (make-vector 3)) (vector-copy! v 0 #(1 2 3)) (assert (equal? #(1 2 3) v))</li>
<li>(assert (let ((v #(5 1 2 3 5))) (equal? #(1 2 3) (vector-copy v 1 4))))</li>
<li>(assert (let ((v #(5 1 2 3))) (equal? #(1 2 3) (vector-copy v 1))))</li>
<li>(assert (let ((v #(1 2 3))) (and (equal? v (vector-copy v)) (not (eq? v (vector-copy v))))))</li>
<li>(assert (equal? #(#\f #\o #\o) (string->vector "xfoox" 1 4)))</li>
<li>(assert (equal? #(#\f #\o #\o) (string->vector "xfoo" 1)))</li>
<li>(assert (equal? #(#\f #\o #\o) (string->vector "foo")))</li>
<li>(assert (string=? "foo" (vector->string #(#\x #\f #\o #\o #\x) 1 4)))</li>
<li>(assert (string=? "foo" (vector->string #(#\x #\f #\o #\o) 1)))</li>
<li>(assert (string=? "foo" (vector->string #(#\f #\o #\o))))</li>
<li>(assert (equal? #(1 2 3) (list->vector '(1 2 3))))</li>
<li>(assert (equal? '(1 2 3) (vector->list #(5 1 2 3 6) 1 4)))</li>
<li>(assert (equal? '(1 2 3) (vector->list #(5 1 2 3) 1)))</li>
<li>(assert (equal? '(1 2 3) (vector->list #(1 2 3))))</li>
<li>(assert (= 3 (vector-ref #(1 2 3 4 5) 2)))</li>
<li>(assert (= 5 (vector-length #(1 2 3 4 5))))</li>
<li>(assert (equal? #(1 2 3) (vector 1 2 3)))</li>
<li>(assert (vector? #(1 2 3)))</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-fill!</li>
<li>vector-append</li>
<li>vector-append</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy!</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>vector-copy</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>string->vector</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>vector->string</li>
<li>list->vector</li>
<li>list->vector</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector->list</li>
<li>vector-ref</li>
<li>vector-ref</li>
<li>vector-length</li>
<li>vector-length</li>
<li>vector</li>
<li>vector</li>
<li>vector?</li>
<li>vector?</li>
</ul>
<h3>r7rs/control</h3>
<h4>|ERROR|</h4>
<ul>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(let ((v '())) (string-for-each (lambda (c x) (set! v (cons (char->integer c) v))) "abcde" "abcdef") (assert (equal? '(101 100 99 98 97) v)))</li>
<li>(define x 0) (for-each (lambda (a b c) (set! x (+ x (+ a b c)))) '(1 2 3 4) '(1 2) '(1 2 3)) (assert (= x 9))</li>
<li>(assert (equal? #(5 7 9) (vector-map + #(1 2 3) #(4 5 6 7))))</li>
<li>(assert (equal? #(1 2 3) (vector-map (lambda (x) (+ x 1)) #(0 1 2))))</li>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
<li>(assert (string=? "ABC" (string-map char-upcase "abc")))</li>
<li>(let ((v '())) (vector-for-each (lambda (a b) (set! v (cons (+ a b) v))) #(1 2 3 4 5) #(1 2 3 4 5 6)) (assert (equal? '(10 8 6 4 2) v)))</li>
<li>(let ((v '())) (string-for-each (lambda (c x) (set! v (cons (char->integer c) v))) "abcde" "abcdef") (assert (equal? '(101 100 99 98 97) v)))</li>
<li>(define x 0) (for-each (lambda (a b c) (set! x (+ x (+ a b c)))) '(1 2 3 4) '(1 2) '(1 2 3)) (assert (= x 9))</li>
<li>(assert (equal? #(5 7 9) (vector-map + #(1 2 3) #(4 5 6 7))))</li>
<li>(assert (equal? #(1 2 3) (vector-map (lambda (x) (+ x 1)) #(0 1 2))))</li>
<li>(assert (string=? "StUdLyCaPs" (string-map (lambda (c k) ((if (eqv? k #\u) char-upcase char-downcase) c)) "studlycaps xxx" "ululululul")))</li>
<li>(assert (string=? "ABC" (string-map char-upcase "abc")))</li>
<li>vector-for-each</li>
<li>vector-for-each</li>
<li>string-for-each</li>
<li>string-for-each</li>
<li>for-each</li>
<li>for-each</li>
<li>vector-map</li>
<li>vector-map</li>
<li>vector-map</li>
<li>vector-map</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
<li>string-map</li>
<li>map</li>
<li>map</li>
</ul>
<h3>r7rs/boolean</h3>
</section>
