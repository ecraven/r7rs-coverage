(load-option 'string-replace-string)
(define (nested-hash-table/put! table value . keys)
  (let loop ((table table)
             (key (car keys))
             (keys (cdr keys)))
    (if (null? keys)
        (hash-table/put! table key value)
        (let ((sub-table (hash-table/get table key #f)))
          (if sub-table
              (loop sub-table (car keys) (cdr keys))
              (let ((sub-table (make-hash-table)))
                (hash-table/put! table key sub-table)
                (loop sub-table (car keys) (cdr keys))))))))

(define (nested-hash-table/get table default . keys)
  (let loop ((table table)
             (key (car keys))
             (keys (cdr keys)))
    (if (null? keys)
        (hash-table/get table key default)
        (let ((sub-table (hash-table/get table key #f)))
          (if sub-table
              (loop sub-table (car keys) (cdr keys))
              default)))))

(define (read-file-content filename)
  "Read the entire file into a string."
  (let* ((size (file-length filename))
         (str (make-string size)))
    (if (= size (read-string! str (open-input-file filename)))
        str
        (error "cannot read entire file" filename))))

(define (read-data)
  (with-input-from-file "errors.csv"
    (lambda ()
      (let loop ((lines '()))
        (let ((line (read-line)))
          (if (eof-object? line)
              (map (lambda (x) (burst-string x #\, #f))
                   (reverse lines))
              (loop (cons line lines))))))))

(define *data* (make-hash-table))
(define *schemes* (make-hash-table))
(define *groups* (make-hash-table))

(define (parse-data)
  (let ((data (read-data)))
    (for-each (lambda (d)
                (let* ((scheme (first d))
                       (version (second d))
                       (key (string->symbol (string-append scheme "-" version)))
                       (group (string->symbol (third d)))
                       (type (string->symbol (fourth d)))
                       (line (fifth d)))
                  (nested-hash-table/put! *data* (cons line (nested-hash-table/get *data* '() key group type)) key group type)
                  (nested-hash-table/put! *schemes* (+ 1 (nested-hash-table/get *schemes* 0 key type)) key type)
                  (nested-hash-table/put! *groups* (+ 1 (nested-hash-table/get *groups* 0 group type)) group type)))
              data)))

(define (format-stats)
  (with-output-to-file "index.html"
    (lambda ()
      (set! *data* (make-hash-table))
      (set! *schemes* (make-hash-table))
      (set! *groups* (make-hash-table))
      (parse-data)
      (format #t "<table><thead><tr><th>Scheme</th><th>Ok</th><th>Error</th></tr></thead><tbody>~%")
      (hash-table-walk *schemes*
                       (lambda (k v)
                         (let ((ok (hash-table/get v '|OK| 0))
                               (error (hash-table/get v '|ERROR| 0)))
                           (format #t "<tr><td>~a</td><td>~a%</td><td>~a</td><td>~a</td></tr>~%" k (inexact (* 100 (/ ok (+ ok error)))) ok error))))
      (format #t "</tbody></table>")
      (format #t "<table><thead><tr><th>Group</th><th>Ok</th><th>Error</th></tr></thead><tbody>~%")
      (hash-table-walk *groups*
                       (lambda (k v)
                         (let ((ok (hash-table/get v '|OK| 0))
                               (error (hash-table/get v '|ERROR| 0)))
                           (format #t "<tr><td>~a</td><td>~a</td><td>~a</td><td>~a</td></tr>~%" k (inexact (* 100 (/ ok (+ ok error)))) ok error))))
      (format #t "</tbody></table>")
      (hash-table-walk *data*
                       (lambda (k v)
                         (format #t "<section><h2>~a</h2>~%" k)
                         (hash-table-walk v
                                          (lambda (k v)
                                            (format #t "<h3>~a</h3>~%" k)
                                            (hash-table-walk v
                                                             (lambda (k v)
                                                               (when (eq? '|ERROR| k)
                                                                 (format #t "<h4>~a</h4>~%" k)
                                                                 (format #t "<ul>~%")
                                                                 (for-each (lambda (x)
                                                                             (format #t "<li>~a</li>~%" (string-replace-string-all x "<" "&lt;")))
                                                                           v)
                                                                 (format #t "</ul>~%"))))))
                         (format #t "</section>~%"))))))
